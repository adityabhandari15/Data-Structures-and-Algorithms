# Data-Structures-and-Algorithms
<p>This project is meant to help beginners understand and code Data Structures and Algorithms
in C. This project strictly follows the book <strong>`Introduction to Algorithms` by Thomas H. Cormen</strong>.
Any beginners strugling with Data Structures and Algorithms are highly recommended to follow
the book. Most of the code is documented properly for beginner audiences to understand easily.
Minimum utilities and libraries are used in case the targeted audience ins't familiar with them.</p>
<p><h5> This project is still in development stage and needs more contributors. </h5></p>
<p><small> Read contributing guidelines in case you want to contribute to this project.</small></p>

## Algorithms Implemented
<p> Algorithms have been mostly implemented in C++ and partially documented. The algorithms implemented are:
<ol>
  <li>Insertion Sort. (location: Algorithms.cpp, line on:[150-165])</li>
  <li> Heap Sort (location: Algorithms.cpp, line no:[331-342])</li>
  <li> Quick Sort (location: Algorithms.cpp, line no:[368-378]) </li>
  <li> Randomized Quick Sort (location: Algorithms.cpp, line no:[360-366]) </li>
  <li> Counting Sort (location: Algorithms.cpp, line no:[392-408]) </li>
  <li> Merge Sort (location: Algorithms.cpp, line no:[410-467]) </li>
  <li> Selection Sort (location: Algorithms.cpp, line no:[484-500]) </li>
  <li> Bubble Sort (location: Algorithms.cpp, line no:[474-482]) </li>
  <li> Linear Search (location: Algorithms.cpp, line no:[133-143]) </li>
  <li> Binary Search (location: Algorithms.cpp, line no:[111-124]) </li>
  <li> Maximum Subarry Problem solved using brute forse, devide and concour and linear methods. (location: Algorithms.cpp, line no:[582-691]) </li>
  <li> Infix to Reverse Polish (postfix) using STACK in C (location: infix_to_postfix/main.c) </li>
  <li> Infix to Polish (prefix) using STACK in C (location: infix_to_prefix/main.c) </li>
  <li> Reverse Polish (postfix) to Polish (prefix) using STACK in C (location: postfix_to_prefix/main.c) </li>
  <li> Reverse Polish (postfix) to Infix using STACK in C (location: postfix_to_infix/main.c) </li>
  <li> Polish (prefix) to Reverse Polish (postfix) using STACK in C (location: prefix_to_postfix/main.c) </li>
  <li> Polish (prefix) to Infix using STACK in C (location: profix_to_infix/main.c) </li>
</ol>
</p>
<p> All the algorithms will be fully documented and implemented in C soon! </p>
  
## Data Structures Implemented
<p> All the Data Structures have been implemented in C. The implemented Data Structures are:
  <ol>
    <li> Stack (fully documented) (C implementation: stack_as_static_array.c, C++ implementtation: stack/stack/headers/Stack.h)</li>
    <li> Queue (documented) (C implementation: queue_using_static_array.c, C++ implementtation: queue/queue/headers/Queue.h)</li>
    <li> Heap (documented) (location: Algorithms.cpp, line no:[168-342])</li>
    <li> Priority Queue (documented) (C implementation: priority_queue.c, C++ implementation: Algorithms.cpp, line no:[168-342]) </li>
    <li> Circular Queue (undocumented) (location: circular_queue_uaing_static_array.c) </li>
    <li> Binary Search Trees (undocumented) (location: binary_tree.c)</li>
    <li> Doubly Linked List (fully documented) (location: doubly_linked_list.c)</li>
    <li> Direct Address Tables (undocumented) (location: direct_address_tables.c)</li>
    <li> Hash Tables (fully documented) (location: hash_tables.c)</li>
  </ol>
</p>

<h1> Dynamic Programming </h1>

<p> Currently under devlopment, some of the Dynamic and Greedy Algoruthms have been implemented in this section. The implementations include: </p>
<ol> 
  <li> Fibonacci Series </li>
  <li> Rod Cutting Problem </li>
  <li> Matrix Chain Multiplication Problem </li>
  <li> Longest Common Subsequence Problem </li>
</ol>

<h3>When does Dynamic Algorithm apply?</h3>
<p>
<ol>
<li> optimal substructure.
    <ul><li>Property of independence holds.</li>
    <li>Property of linearity holds.</li>
    <li>Choices hold both for subproblems and problems.</li></ul>
</li>
<li> overlapping subproblems.</li>
</ol>
</p>

<h3>Elements of Dynamic Programming:</h3>
<p>
<ol> 
<li> Optimal Substucture.</li>
<li> Overlapping Subproblems.</li>
<li> Reconstructing a optimal solution.</li>
<li> Memoization for top-down approach.</li>
</ol>
</p>


<h3>Attack plan:</h3>
<p>
<ol>
<li> Characterize the stucture of an optimum solution.</li>
<li> Recursively define the value of an optimum solution.</li>
<li> Compute the value of optimum solution.</li>
<li> Construct an optimal solution from computed information.</li>
</ol>
</p>

<h3>Examples:</h3>
<p> 
<ol>
<li> Rod cutting Problem.</li>
<li> Matrix Chain Multiplication.</li>
<li> Shortest Path in unweighed directed graph.</li>
<li> Longest Common Sub-Sequence.</li>
</ol>
</p>


<h3>Where it doesn't apply:</h3>
<p>
<ol>
<li> Longest Path in unweighed directed graph.</li>
<li> Rod cutting with limit of cuts.</li>
</ol>
</p>



## Thanking you!
<small> Please read the contributing guidelines if you wish to contribute!</small>
